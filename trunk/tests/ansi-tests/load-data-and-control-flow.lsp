;;; Tests of data and control flow

(load "data-and-control-flow.lsp")
(load "places.lsp")
(load "psetq.lsp")
(load "psetf.lsp")
(load "shiftf.lsp")
(load "rotatef.lsp")
(load "return.lsp")
(load "return-from.lsp")
(load "defsetf.lsp")
(load "define-setf-expander.lsp")

(load "and.lsp")
(load "apply.lsp")
(load "block.lsp")
(load "call-arguments-limit.lsp")
(load "case.lsp")
(load "catch.lsp")
(load "ccase.lsp")
(load "compiled-function-p.lsp")
(load "complement.lsp")
(load "cond.lsp")
(load "constantly.lsp")
(load "ctypecase.lsp")
(load "defconstant.lsp")
(load "define-modify-macro.lsp")
(load "defparameter.lsp")
(load "defun.lsp")
(load "defvar.lsp")
(load "destructuring-bind.lsp")
(load "ecase.lsp")
(load "eql.lsp")
(load "equal.lsp")
(load "equalp.lsp")
(load "etypecase.lsp")
(load "every.lsp")
(load "fboundp.lsp")
(load "fdefinition.lsp")
(load "flet.lsp")
(load "fmakunbound.lsp")
(load "funcall.lsp")
(load "function-lambda-expression.lsp")
(load "function.lsp")
(load "functionp.lsp")
(load "get-setf-expansion.lsp")
(load "identity.lsp")
(load "if.lsp")
(load "labels.lsp")
(load "lambda-list-keywords.lsp")
(load "lambda-parameters-limit.lsp")
(load "let.lsp")
(load "letstar.lsp")
(load "macrolet.lsp")
(load "multiple-value-bind.lsp")
(load "multiple-value-call.lsp") ;; include multiple-value-list
(load "multiple-value-prog1.lsp")
(load "multiple-value-setq.lsp")
(load "multiple-value-list.lsp")
(load "nil.lsp")
(load "not-and-null.lsp")
(load "notany.lsp")
(load "notevery.lsp")
(load "nth-value.lsp")
(load "or.lsp")
(load "prog.lsp")
(load "prog1.lsp")
(load "prog2.lsp")
(load "progn.lsp")
(load "progv.lsp")
(load "some.lsp")
(load "t.lsp")
(load "tagbody.lsp")
(load "typecase.lsp")
(load "unless.lsp")
(load "unwind-protect.lsp")
(load "values-list.lsp")
(load "values.lsp")
(load "when.lsp")
